function [u p] = StoDLP_closeglobal(t, s, mu, sigma, side)
% STODLP_CLOSEGLOBAL - close-eval velocity Stokes DLP w/ global quadr curve
%
% u = StoDLP_closeglobal(t,s,mu,dens,side) returns velocities at targets t.x
%  due to double-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  or outside the curve.
%  The DLP velocity is broken down into 5 Laplace DLP-like (2 are Cauchy)
%  potential calls, each of which are evaluated with the globally-compensated
%  scheme. See [lsc2d] for details.
%  The pressure uses the gradient of a single Laplace DLP call.
%
% [u p] = StoDLP_closeglobal(t,s,mu,dens,side) also returns pressure at targets
%
% Inputs:
%  t = target struct with t.x = M-by-1 list of targets in complex plane
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
%  mu = viscosity in Stokes equations (real positive number); has no effect on
%     DLP but is part of the standard interface.
%  dens = double-layer density values (2N-by-1) at nodes, with real values
%     (1-cpts followed by 2-cpts).
%     If dens is empty, output u is the full 2M-by-2N evaluation matrix.
%  side = 'i','e' to indicate targets are all interior or exterior to curve.
%
% Outputs:
%  u = velocity values at targets (2M-by-1): all 1- then all 2-cmpts.
%      Or, if 2M-by-2N velocity evaluation matrix (if dens=[])
%  p = pressure values at targets (M-by-1), or M-by-2N evaluation matrix.
%
% Called without arguments, a self-test (far eval & mat vs StoDLP) is done.
%
% Also see: STODLP, SETUPQUAD, STOINTDIRBVP

% Bowei Wu, Sept 2014; Barnett 10/8/14 tweaks, repackage 6/13/16.
% viscosity input (doesn't affect result) 6/27/16. pressure 6/29/16.
% todo: * speed up matrix filling exploiting incoming 0s, do mult of Nf*Nf
%  efficiently-filled LapDLP_closeglobal, against the Nf*N dense interp mat,
%  will be O(MN^2) but fast.

if nargin==0, test_StoDLP_closeglobal; return; end

N=size(s.x,1); M=size(t.x,1);       % # srcs, # targs
mat = isempty(sigma);
if mat, sigma=eye(2*N); end         % case of dense matrix
sigma = sigma(1:N,:)+1i*sigma(N+1:end,:);  % put into complex notation
Nc = size(sigma,2);                 % # density vecs (cols)

% find I_1:
% Bowei's version with "illegal" complex tau, with interp to fine nodes
beta = 2.2;  % >=1: how many times more dense to make fine nodes, for I_1
Nf = ceil(beta*numel(s.x)/2)*2;  % nearest even # fine nodes
sf.x = perispecinterp(s.x,Nf); sf = setupquad(sf); % build fine nodes
sigf=zeros(Nf,Nc);
for k=1:Nc
  sigf(:,k) = perispecinterp(sigma(:,k),Nf);     % fine Stokes density
end
% feed complex tau to Laplace close eval - careful:
tauf = bsxfun(@times, sigf, real(sf.nx)./sf.nx);    % undo n_y rotation
I1x1 = LapDLP_closeglobal(t, sf, tauf, side);
tauf = bsxfun(@times, sigf, imag(sf.nx)./sf.nx);    % undo n_y rotation
I1x2 = LapDLP_closeglobal(t, sf, tauf, side);
% Note: for mat fill the above would be faster done by mat-mat prod
I1 = I1x1+1i*I1x2;

% find I_2
tau = real(bsxfun(@times,s.x,conj(sigma)));
[~, I2x1, I2x2] = LapDLP_closeglobal(t, s, tau, side);
I2 = I2x1+1i*I2x2;

% find I_3 and I_4
if ~mat
    [~, I3x1, I3x2] = LapDLP_closeglobal(t, s, real(sigma), side);
    I3 = bsxfun(@times, real(t.x), I3x1+1i*I3x2);
    [~, I4x1, I4x2] = LapDLP_closeglobal(t, s, imag(sigma), side);
    I4 = bsxfun(@times, imag(t.x), I4x1+1i*I4x2);
else        % *** specific to the matrix case, not arb Nc...
    [~, L1, L2] = LapDLP_closeglobal(t, s, eye(N), side);  % only need 1 call
    I4x1=[zeros(M,N),L1];      % could be tidied up, but not a bottleneck...
    I4x2=[zeros(M,N),L2];
    I3x1=[L1,zeros(M,N)];
    I3x2=[L2,zeros(M,N)];
    I3 = bsxfun(@times,real(t.x),I3x1+1i*I3x2);
    I4 = bsxfun(@times,imag(t.x),I4x1+1i*I4x2);
end

u = I1+I2-I3-I4;
u=[real(u);imag(u)];    % back to real notation, always stack [u1;u2]

% test which is causing slow convergence at nearby pt (side='e', vary N):
% jj= find(abs(x - (0.7-0.9i))<1e-12); I1(jj), I2(jj), I3(jj)+I4(jj)
% ans: it's I1, of course. (Alex, 2013)

if nargout>1  % ----------- want pressure, do its extension (not in [lsc2c])
  if ~mat
    p = -2*mu*(I3x1 + I4x2);   % already computed for u, turns out easy
  else
    p = -2*mu*[L1,L2];         % "
  end
end

%%%%%%%%%%%%%%%%%%%%
function test_StoDLP_closeglobal          % adapted from Lap tests
fprintf('check Stokes DLP close-eval quadr match native rule in far field...\n')
verb = 0;       % to visualize
s = wobblycurve(1,0.3,5,280); s.a = mean(s.x); if verb,figure;showsegment(s);end
mu = 0.9;       % viscosity (real, pos)
tau = [0.7+sin(3*s.t); -0.4+cos(2*s.t)];  % pick smooth density w/ nonzero mean
nt = 100; t.nx = exp(2i*pi*rand(nt,1));  % target normals
%profile clear; profile on;
for side = 'ie'
  if side=='e', t.x = 1.5+1i+rand(nt,1)+1i*rand(nt,1);         % distant targs
  else, t.x = 0.6*(rand(nt,1)+1i*rand(nt,1)-(0.5+0.5i)); end % targs far inside
  if verb, plot(t.x,'.'); end
  fprintf('\nside = %s:\n',side)
  [u p] = StoSLP(t,s,mu,tau);    % eval given density cases...
  tic, [uc pc] = StoSLP_closeglobal(t,s,mu,tau,side);
  fprintf('Sto DLP density eval (%.3g sec), max abs err in u cmpts, p:\n',toc)
  disp([max(abs(u-uc)), max(abs(p-pc))])
  tic, [Ac Pc] = StoSLP_closeglobal(t,s,mu,[],side); % fill 20x slower than apply
  fprintf('matrix fill (%.3g sec) & apply, max abs err in u cmpts, p:\n',toc)
  disp([max(abs(u-Ac*tau)), max(abs(p-Pc*tau))])
  [A P] = StoSLP(t,s,mu);   % compare matrix els...
  fprintf('matrix fill, max abs matrix element diffs for u, p (more stringent, not needed):\n')
  disp([max(abs(A(:)-Ac(:))), max(abs(P(:)-Pc(:)))])
end
%profile off; profile viewer
