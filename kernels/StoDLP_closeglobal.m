function [u p] = StoDLP_closeglobal(t, s, mu, sigma, side)
% STODLP_CLOSEGLOBAL - close-eval velocity Stokes DLP w/ global quadr curve
%
% u = StoDLP_closeglobal(t,s,mu,dens,side) returns velocities at targets t.x
%  due to double-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  or outside the curve.
%  The DLP is broken down into 5 Laplace DLP-like (2 are Cauchy) potential
%  calls, each of which are evaluated with the globally-compensated scheme.
%  See [lsc2d] for details.
%
% [u p] = StoDLP_closeglobal(t,s,mu,dens,side) also returns pressure at targets
%
% Inputs:
%  t = target struct with t.x = M-by-1 list of targets in complex plane
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
%  mu = viscosity in Stokes equations (real positive number); has no effect on
%     DLP but is part of the standard interface.
%  dens = double-layer density values (2N-by-1) at nodes, with real values
%     (1-cpts followed by 2-cpts).
%     If dens is empty, output u is the full 2M-by-2N evaluation matrix.
%  side = 'i','e' to indicate targets are all interior or exterior to curve.
%
% Outputs:
%  u = velocity values at targets (2M-by-1): all 1- then all 2-cmpts.
%      Or, if 2M-by-2N velocity evaluation matrix (if dens=[])
%  p = pressure values at targets (M-by-1), or M-by-2N evaluation matrix.
%
% Also see: SETUPQUAD, STOINTDIRBVP

% Bowei Wu, Sept 2014; Barnett 10/8/14 tweaks, repackage 6/13/16.
% viscosity input (doesn't affect result) 6/27/16
% todo: * speed up matrix filling exploiting incoming 0s, do mult of Nf*Nf
%  efficiently-filled LapDLP_closeglobal, against the Nf*N dense interp mat,
%  will be O(MN^2) but fast.

N=size(s.x,1); M=size(t.x,1);       % # srcs, # targs

mat = isempty(sigma);
if mat, sigma=eye(2*N); end         % case of dense matrix
sigma = sigma(1:N,:)+1i*sigma(N+1:end,:);  % put into complex notation

Nc = size(sigma,2);                 % # density vecs (cols)

% find I_1:
% Bowei's version with "illegal" complex tau, with interp to fine nodes
beta = 2.2;  % >=1: how many times more dense to make fine nodes, for I_1
Nf = ceil(beta*numel(s.x)/2)*2;  % nearest even # fine nodes
sf.x = perispecinterp(s.x,Nf); sf = setupquad(sf); % build fine nodes
sigf=zeros(Nf,Nc);
for k=1:Nc
  sigf(:,k) = perispecinterp(sigma(:,k),Nf);     % fine Stokes density
end
% feed complex tau to Laplace close eval - careful:
tauf = sigf./(sf.nx*ones(1,Nc)).*(real(sf.nx)*ones(1,Nc));
I1x1 = LapDLP_closeglobal(t, sf, tauf, side);
tauf = sigf./(sf.nx*ones(1,Nc)).*(imag(sf.nx)*ones(1,Nc));
I1x2 = LapDLP_closeglobal(t, sf, tauf, side);
% Note: for mat fill the above would be faster done by mat-mat prod
I1 = I1x1+1i*I1x2;


% find I_2
tau = real((s.x*ones(1,Nc)).*conj(sigma));
[~, I2x1, I2x2] = LapDLP_closeglobal(t, s, tau, side);
I2 = I2x1+1i*I2x2;

if ~mat
    tau = real(sigma);
    [~, I3x1, I3x2] = LapDLP_closeglobal(t, s, tau, side);
    I3 = (real(t.x)*ones(1,Nc)).*(I3x1+1i*I3x2);
    
    tau = imag(sigma);
    [~, I4x1, I4x2] = LapDLP_closeglobal(t, s, tau, side);
    I4 = (imag(t.x)*ones(1,Nc)).*(I4x1+1i*I4x2);
else
    tau = real(sigma(:,1:N));      % *** specific to the matrix case, not arb Nc
    [~, I3x1, I3x2] = LapDLP_closeglobal(t, s, tau, side);
    I4x1=[zeros(M,N),I3x1];
    I4x2=[zeros(M,N),I3x2];
    I3x1=[I3x1,zeros(M,N)];
    I3x2=[I3x2,zeros(M,N)];
    I3 = (real(t.x)*ones(1,Nc)).*(I3x1+1i*I3x2);
    I4 = (imag(t.x)*ones(1,Nc)).*(I4x1+1i*I4x2);
end

u = I1+I2-I3-I4;

u=[real(u);imag(u)];    % back to real notation, always stack [u1;u2]

% test which is causing slow convergence at nearby pt (side='e', vary N):
% jj= find(abs(x - (0.7-0.9i))<1e-12); I1(jj), I2(jj), I3(jj)+I4(jj)
% ans: it's I1, of course. (Alex, 2013)

if nargout>1   % want pressure, do its extension
    % *** need to resample to fine ???
  p = [];  % *** todo
  %tau = bsxfun(@times, sigma, conj(s.nx));   % 2 complex cmpts
  %p = LapDLP_closeglobal(t, s, tau, side);
  
  
  
  p = real(p);
end
