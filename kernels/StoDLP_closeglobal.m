function u = StoDLP_closeglobal(t, s, sigma, side)
% STODLP_CLOSEGLOBAL - close-eval velocity Stokes DLP w/ global quadr curve
%
% u = StoDLP_closeglobal(t,s,dens,side) returns velocities at targets t.x
%  due to double-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  outside the curve.
%  The DLP is broken down into 5 Laplace DLP-like (2 are Cauchy) potential
%  calls, each of which are evaluated with the globally-compensated scheme.
%  See [lsc2d] for details.
%
% Inputs:
%  t = target struct with t.x = M-by-1 list of targets in complex plane 
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
%  dens = double-layer density values (N-by-1) at nodes, in complex notation:
%     real, imag contains the 1,2 vector components.
%  side = 'i','e' to indicate targets are all interior or exterior to curve.
%
% Outputs:
%  u = velocity values at targets x (M-by-1): real, imag contains 1,2 components
%
% Also see: SETUPQUAD, testStokesSDevalclose.m
%
% Bowei Wu, Sept 2014; Barnett 10/8/14 tweaks, repackage 6/13/16.

if nargin<4, side = 'e'; end        % default

N=size(s.x,1);
M=size(x,1);

if isempty(sigma)
    sigma=eye(2*N);
    sigma=sigma(1:N,:)+1i*sigma(N+1:end,:);
    ui=1;
else
    ui=0;
end

n=size(sigma,2);

% find I_1:
% Bowei's version with "illegal" complex tau, with interp to fine nodes
beta = 2.2;  % >=1: how many times more dense to make fine nodes, for I_1
NE = ceil(beta*numel(s.x)/2)*2;  % nearest even # fine nodes
sf.x = fftinterp(s.x,NE); sf = quadr(sf); % build fine nodes
sigf=zeros(NE,n);
for k=1:n
    sigf(:,k) = fftinterp(sigma(:,k),NE);     % fine Stokes density <==================================================================
end
%sigf = fftinterp(sigma,N);     % fine Stokes density
tauf = sigf./(sf.nx*ones(1,n)).*(real(sf.nx)*ones(1,n));  % feed complex tau to Laplace close eval
I1x1 = lapDevalclose(x, sf, tauf, side);
tauf = sigf./(sf.nx*ones(1,n)).*(imag(sf.nx)*ones(1,n));
I1x2 = lapDevalclose(x, sf, tauf, side);
I1 = I1x1+1i*I1x2;

% find I_2
tau = real((s.x*ones(1,n)).*conj(sigma));
[~, I2x1, I2x2] = lapDevalclose(x, s, tau, side);
I2 = I2x1+1i*I2x2;

if ui==0
    tau = real(sigma);
    [~, I3x1, I3x2] = lapDevalclose(x, s, tau, side);
    I3 = (real(x)*ones(1,n)).*(I3x1+1i*I3x2);
    
    tau = imag(sigma);
    [~, I4x1, I4x2] = lapDevalclose(x, s, tau, side);
    I4 = (imag(x)*ones(1,n)).*(I4x1+1i*I4x2);
else
    tau=real(sigma(:,1:N));
    [~, I3x1, I3x2] = lapDevalclose(x, s, tau, side);
    I4x1=[zeros(M,N),I3x1];
    I4x2=[zeros(M,N),I3x2];
    I3x1=[I3x1,zeros(M,N)];
    I3x2=[I3x2,zeros(M,N)];
    I3 = (real(x)*ones(1,n)).*(I3x1+1i*I3x2);
    I4 = (imag(x)*ones(1,n)).*(I4x1+1i*I4x2);
end

u = I1+I2-I3-I4;

if ui==1
    u=[real(u);imag(u)];
end

% test which is causing slow convergence at nearby pt (side='e', vary N):
% jj= find(abs(x - (0.7-0.9i))<1e-12); I1(jj), I2(jj), I3(jj)+I4(jj)
% ans: it's I1, of course. (Alex)

% keyboard
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end main %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function testfftinterp
n = 50;
N = 100;
x = 2*pi*(0:n-1)/n;
f = @(x) exp(sin(x));
g = fftinterp(f(x),N);
ge = f(2*pi*(0:N-1)/N);
% g ./ ge
norm(g - ge)

function g = fftinterp(f,N)
% FFTINTERP - resample periodically sampled function onto finer grid
%
% g = fftinterp(f,N)
% inputs:  f - (row or column) vector length n of samples
%          N - desired output number of samples, must be >= n
% outputs: g - vector length N of interpolant, (row or col as f was)
% Note on phasing: the output and input grid first entry align.
% Barnett 9/5/14.  To do: downsample case N<n
n = numel(f);
if N==n, g = f; return; end
if mod(N,2)~=0 || mod(n,2)~=0, warning('N and n must be even'); end
F = fft(f(:).');    % row vector
g = ifft([F(1:n/2) F(n/2+1)/2 zeros(1,N-n-1) F(n/2+1)/2 F(n/2+2:end)]);
g = g*(N/n);   % factor from the ifft
if size(f,1)>size(f,2), g = g(:); end % make col vector
