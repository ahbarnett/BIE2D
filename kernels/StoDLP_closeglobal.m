function u = StoDLP_closeglobal(t, s, mu, sigma, side)
% STODLP_CLOSEGLOBAL - close-eval velocity Stokes DLP w/ global quadr curve
%
% u = StoDLP_closeglobal(t,s,mu,dens,side) returns velocities at targets t.x
%  due to double-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  or outside the curve.
%  The DLP is broken down into 5 Laplace DLP-like (2 are Cauchy) potential
%  calls, each of which are evaluated with the globally-compensated scheme.
%  See [lsc2d] for details.
%
% Inputs:
%  t = target struct with t.x = M-by-1 list of targets in complex plane
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
%  mu = viscosity in Stokes equations (real positive number); has no effect on
%     DLP but is part of the standard interface.
%  dens = double-layer density values (2N-by-1) at nodes, with real values
%     (1-cpts followed by 2-cpts).
%     If dens is empty, output u is the full 2M-by-2N evaluation matrix.
%  side = 'i','e' to indicate targets are all interior or exterior to curve.
%
% Outputs:
%  u = velocity values at targets (2M-by-1): all 1- then all 2-cmpts.
%      Or, if 2M-by-2N velocity evaluation matrix (if dens=[])

% Also see: SETUPQUAD, STOINTDIRBVP, testStokesSDevalclose.m
%
% Bowei Wu, Sept 2014; Barnett 10/8/14 tweaks, repackage 6/13/16.
% viscosity input, doesn't affect result. 6/27/16
% todo: * speed up matrix filling exploiting incoming 0s, do mult of Nf*Nf
%  efficiently-filled LapDLP_closeglobal, against the Nf*N dense interp mat,
%  will be O(MN^2) but fast.

N=size(s.x,1); M=size(t.x,1);       % # srcs, # targs

mat = isempty(sigma);
if mat, sigma=eye(2*N); end         % case of dense matrix
sigma = sigma(1:N,:)+1i*sigma(N+1:end,:);  % put into complex notation

Nc = size(sigma,2);                 % # density vecs (cols)

% find I_1:
% Bowei's version with "illegal" complex tau, with interp to fine nodes
beta = 2.2;  % >=1: how many times more dense to make fine nodes, for I_1
Nf = ceil(beta*numel(s.x)/2)*2;  % nearest even # fine nodes
sf.x = perispecinterp(s.x,Nf); sf = setupquad(sf); % build fine nodes
sigf=zeros(Nf,Nc);
for k=1:Nc
  sigf(:,k) = perispecinterp(sigma(:,k),Nf);     % fine Stokes density
end
% feed complex tau to Laplace close eval - careful:
tauf = sigf./(sf.nx*ones(1,Nc)).*(real(sf.nx)*ones(1,Nc));
I1x1 = LapDLP_closeglobal(t, sf, tauf, side);
tauf = sigf./(sf.nx*ones(1,Nc)).*(imag(sf.nx)*ones(1,Nc));
I1x2 = LapDLP_closeglobal(t, sf, tauf, side);
% Note: the above would be faster done by mat-mat prod of 
I1 = I1x1+1i*I1x2;


% find I_2
tau = real((s.x*ones(1,Nc)).*conj(sigma));
[~, I2x1, I2x2] = LapDLP_closeglobal(t, s, tau, side);
I2 = I2x1+1i*I2x2;

if ~mat
    tau = real(sigma);
    [~, I3x1, I3x2] = LapDLP_closeglobal(t, s, tau, side);
    I3 = (real(t.x)*ones(1,Nc)).*(I3x1+1i*I3x2);
    
    tau = imag(sigma);
    [~, I4x1, I4x2] = LapDLP_closeglobal(t, s, tau, side);
    I4 = (imag(t.x)*ones(1,Nc)).*(I4x1+1i*I4x2);
else
    tau = real(sigma(:,1:N));      % *** specific to the matrix case, not arb Nc
    [~, I3x1, I3x2] = LapDLP_closeglobal(t, s, tau, side);
    I4x1=[zeros(M,N),I3x1];
    I4x2=[zeros(M,N),I3x2];
    I3x1=[I3x1,zeros(M,N)];
    I3x2=[I3x2,zeros(M,N)];
    I3 = (real(t.x)*ones(1,Nc)).*(I3x1+1i*I3x2);
    I4 = (imag(t.x)*ones(1,Nc)).*(I4x1+1i*I4x2);
end

u = I1+I2-I3-I4;

u=[real(u);imag(u)];    % always stack [u1;u2]

% test which is causing slow convergence at nearby pt (side='e', vary N):
% jj= find(abs(x - (0.7-0.9i))<1e-12); I1(jj), I2(jj), I3(jj)+I4(jj)
% ans: it's I1, of course. (Alex)

% keyboard
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% end main %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% *** break into utils:

function testfftinterp
n = 50;
N = 100;
x = 2*pi*(0:n-1)/n;
f = @(x) exp(sin(x));
g = fftinterp(f(x),N);
ge = f(2*pi*(0:N-1)/N);
% g ./ ge
norm(g - ge)

function g = fftinterp(f,N)
% FFTINTERP - resample periodically sampled function onto finer grid
%
% g = fftinterp(f,N)
% inputs:  f - (row or column) vector length n of samples
%          N - desired output number of samples, must be >= n
% outputs: g - vector length N of interpolant, (row or col as f was)
% Note on phasing: the output and input grid first entry align.
% Barnett 9/5/14.  To do: downsample case N<n
n = numel(f);
if N==n, g = f; return; end
if mod(N,2)~=0 || mod(n,2)~=0, warning('N and n must be even'); end
F = fft(f(:).');    % row vector
g = ifft([F(1:n/2) F(n/2+1)/2 zeros(1,N-n-1) F(n/2+1)/2 F(n/2+2:end)]);
g = g*(N/n);   % factor from the ifft
if size(f,1)>size(f,2), g = g(:); end % make col vector
