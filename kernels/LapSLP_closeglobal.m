function [u ux uy info] = LapSLP_closeglobal(t, s, tau, side)
% LAPSLP_CLOSEGLOBAL - Laplace SLP potential & deriv w/ global close-eval quad
%
% u = LapSLP_closeglobal(t,s,dens,side) returns potentials at targets t.x
%  due to single-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  outside the curve. The new global scheme of [lsc2d] based on barycentric
%  Cauchy close-evaluation (see reference in Cau_closeglobal.m) is used.
% 
% Our definition of the SLP on curve Gamma is
%
%    u(x) = (1/2pi) int_Gamma log(1/|r|) tau(y) ds_y,  where r:=x-y,  x,y in R2
%
% Inputs:
%  t = target struct containing
%      t.x = M-by-1 list of targets, as points in complex plane
%      (optionally also t.nx target normals as unit complex numbers)
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and other fields as generated by setupquad.
%     Also needed (for side='e'): s.a, a point interior to the curve.
%  dens = single-layer density values at nodes. Note, must be real-valued to
%     evaluate Laplace layer potentials (note Stokes feeds it complex dens).
%     If dens has multiple columns, the evaluation is done for each.
%     If dens is empty, outputs are matrices mapping density to values, etc.
%  side = 'i','e' to indicate targets are interior or exterior to the curve.
%
% Outputs:
%  u = column vector of M potential values where M = numel(t.x), or if
%      dens has n columns, the n column vector outputs are stacked (M-by-n).
%  [u un] = LapSLPeval_closeglobal(t,s,dens,side) also returns target-normal
%           derivatives (M-by-n) using t.nx
%  [u ux uy] = LapSLPeval_closeglobal(t,s,dens,side) instead returns x- and y-
%           partials of u at the targets (ignores t.nx)
%  [u ux uy info] = LapSLPeval_closeglobal(t,s,dens,side) also gives diagnostic:
%           info.vb = vector of v boundary values (M-by-n)
%           info.imv = imag part of v at targets (M-by-n)
%
% References:
%
%  [lsc2d] Spectrally-accurate quadratures for evaluation of layer potentials
%          close to the boundary for the 2D Stokes and Laplace equations,
%          A. H. Barnett, B. Wu, and S. Veerapaneni, SIAM J. Sci. Comput.,
%          37(4), B519-B542 (2015)   https://arxiv.org/abs/1410.2187
%
% See also: LAPSLP, SETUPQUAD, CAU_CLOSEGLOBAL, LAPINTDIRBVP
%
% complexity O(N^2) for evaluation of v^+ or v^-, plus O(NM) for globally
% compensated quadrature to targets

% Barnett 2013; multiple-column generalization by Gary Marple, 2014.
% Repackaged Barnett 6/12/16, 6/27/16 col vec outputs, 6/28/16 vp 'e' corrected
% todo: * efficient special case of matrix filling, join Steps 1 & 2 with dgemm.

if nargin==0
  %testCSLPselfmatrix;
  test_LapSLP_closeglobal; return; end
N = numel(s.x); M = numel(t.x);     % # source, target nodes
if isempty(tau), tau = eye(N); end  % case of filling matrices
n = size(tau,2);                    % # density columns

% Step 1: eval v^+ or v^- = cmplx SLP(tau):
vb = CSLPselfmatrix(s,side) * tau;
if side=='e'
  sawlog = s.t/1i + log(s.a - s.x);  % sawtooth with jump cancelled by log
  for i=1:numel(sawlog)-1, p = imag(sawlog(i+1)-sawlog(i)); % remove phase jumps
    sawlog(i+1) = sawlog(i+1) - 2i*pi*round(p/(2*pi)); end
  totchgp = sum((s.w*ones(1,n)).*tau,1)/(2*pi);       % total charge due to SLP, over 2pi (suffix p is for n-cmpt row vec)
  vb = vb + sawlog*totchgp;           % is now r
  cw = 1i*s.nx.*s.w;  % complex speed weights for native quadr...
  vinf = sum(bsxfun(@times, vb, cw./(s.x-s.a)),1) / (2i*pi); % interior Cauchy gets v_infty
  vb = vb - ones(size(vb,1),1)*vinf;  % kill off v_infty so that v is in exterior Hardy space
end
info.vb = vb;  % save for diagnostics (if totchg=0 it's useful)

% Step 2: compensated close-evaluation of v & v', followed by take Re:
if nargout>1                                % want derivatives
  [v vp] = Cau_closeglobal(t.x,s,vb,side);  % does Sec. 3 of [lsc2d]
  ux = real(vp); uy = -imag(vp);            % col vecs, leave as partials...
  if nargout==2    % or dot w/ targ nor...
    ux = bsxfun(@times,ux,real(t.nx)) + bsxfun(@times,uy,imag(t.nx));
  end
else
  v = Cau_closeglobal(t.x,s,vb,side);        % does Sec. 3 of [lsc2d]
end
u = real(v);
if side=='e'         % add real part of log and of v_infty back in...
  u = u - log(abs(s.a - t.x))*totchgp + ones(M,1)*real(vinf);   % Re v_infty = 0 anyway
  if nargout==2      % don't forget to correct the derivs too!
    ux = ux + real(t.nx./(s.a - t.x))*totchgp;
  elseif nargout==3
    ux = ux + real(1./(s.a - t.x))*totchgp;
    uy = uy - imag(1./(s.a - t.x))*totchgp;
  end
end
%%%%%%

function S = CSLPselfmatrix(s,side) % complex SLP Kress-split Nystrom matrix
% s = src seg, even # nodes. side = 'i'/'e' int/ext case. Barnett 10/18/13.
% only correct for zero-mean densities.
N = numel(s.x);
d = s.x*ones(1,N) - ones(N,1)*s.x.';      % C-# displacements mat, t-s
x = exp(1i*s.t); % unit circle nodes relative to which angles measured.
S = -log(d) + log(x*ones(1,N) - ones(N,1)*x.'); % NB circ angles
S(diagind(S)) = log(1i*x./s.xp);               % complex diagonal limit
% O(N^2) hack to remove 2pi phase jumps in S (assumes enough nodes for smooth):
for i=1:numel(S)-1, p = imag(S(i+1)-S(i));  % phase jump between pixels
  S(i+1) = S(i+1) - 2i*pi*round(p/(2*pi)); end % (NB access matrix as 1d array!)
%figure; imagesc(real(S)); figure; imagesc(imag(S)); stop % check S mat smooth
  
m = 1:N/2-1; if side=='e', Rjn = ifft([0 1./m 1/N 0*m]); % imag sign dep on side
else, Rjn = ifft([0 0*m 1/N 1./m(end:-1:1)]); end     % cmplx Kress Rj(N/2)/4pi
%m = 1:N/2-1; Rjn = ifft([0 0*m 1/N 1./m(end:-1:1)]); Rjn = [Rjn(1) Rjn(end:-1:2)]; % flips order
S = S/N + circulant(Rjn); % incl 1/2pi SLP prefac. drops const part in imag
S = bsxfun(@times, S, s.sp.');  % include speed (2pi/N weights already in)


%%%%%%%%%%%%%%%%%%%
function testCSLPselfmatrix % test spectral conv of complex SLP self-int Nystrom
% Barnett 10/18/13, repackaged 6/27/16
s = wobblycurve(1,0.3,5,200);
fprintf('CSLP self matrix test, check digits freeze:\n')
for N=40:40:500  % convergence study of Re v, Im v...
  s = setupquad(s,N); sig = cos(3*s.t + 1); % zero-mean real SLP density func
  v = CSLPselfmatrix(s,'i') * sig;          % holomorphic potential bdry value
  fprintf('N=%d:\tu(s=0) = %.15g  Im[v(s=0)-v(s=pi)] = %.15g\n',N,real(v(end)),imag(v(end)-v(end/2))); % note overall const for Im not high-order convergence
end % NB needs N=320 for 13 digits in Re, but 480 for Im part (why slower?)
%figure; plot(s.t, [real(v) imag(v)], '+-'); title('Re and Im of v=S\sigma');

%%%%%%%%%%%%%%%%%%%%
function test_LapSLP_closeglobal
fprintf('check Laplace SLP close-eval quadr match native rule in far field...\n')
verb = 1;       % to visualize
s = wobblycurve(1,0.3,5,200); s.a = mean(s.x)+0.4+0.2i;  % can't be near bdry
if verb, figure; showsegment(s); plot(s.a,'+'); end
tau = -0.7+exp(sin(3*s.t));              % pick smooth density w/ nonzero mean
nt = 100; t.nx = exp(2i*pi*rand(nt,1));  % target normals
for side = 'ie'
  if side=='e', t.x = 1.5+1i+rand(nt,1)+1i*rand(nt,1);         % distant targs
  else, t.x = 0.6*(rand(nt,1)+1i*rand(nt,1)-(0.5+0.5i)); end % targs far inside
  if verb, plot(t.x,'.'); end
  fprintf('\nside = %s:\n',side)
  [u un] = LapSLP(t,s,tau);    % eval given density cases...
  [uc unc] = LapSLP_closeglobal(t,s,tau,side);
  tic, [uc uxc uyc] = LapSLP_closeglobal(t,s,tau,side);
  fprintf('Lap SLP density eval (%.3g sec), max abs err in u, un, and [ux,uy]...\n',toc)
  disp([max(abs(u-uc)), max(abs(un-unc)), max(abs(un - (uxc.*real(t.nx)+uyc.*imag(t.nx))))])
  [uc unc] = LapSLP_closeglobal(t,s,[],side);
  tic, [uc uxc uyc] = LapSLP_closeglobal(t,s,[],side);
  fprintf('matrix fill (%.3g sec) & apply, max abs err in u, un, and [ux,uy]...:\n',toc)
  disp([max(abs(u-uc*tau)), max(abs(un-unc*tau)), max(abs(un - ((uxc*tau).*real(t.nx)+(uyc*tau).*imag(t.nx))))])
  [u un] = LapSLP(t,s);   % compare matrix els....
  fprintf('matrix fill, max abs matrix element diffs in u, un, and [ux,uy]...\n')
  disp([max(abs(u(:)-uc(:))), max(abs(un(:)-unc(:))), max(max(abs(un - (bsxfun(@times,uxc,real(t.nx))+bsxfun(@times,uyc,imag(t.nx))))))])
end

