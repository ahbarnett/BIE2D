function [u p T] = StoSLP_closeglobal(t, s, mu, sigma, side)
% STOSLP_CLOSEGLOBAL - close-eval velocity Stokes SLP w/ global quadr curve
%
% u = StoSLP_closeglobal(t,s,mu,dens,side) returns velocities at targets t.x
%  due to single-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  or outside the curve.
%  The SLP for velocity is broken down into 3 Laplace SLP potential calls,
%  each of which are evaluated with the globally-compensated scheme.
%  See [lsc2d] for details (except we include viscosity prefactor).
%  The pressure uses a single Laplace DLP call, using the complex density
%  tau = sigma_1 + i.sigma_2.
%
% [u p] = StoSLP_closeglobal(t,s,mu,dens,side) also returns pressure at targets
% [u p T] = StoSLP_closeglobal(t,s,mu,dens,side) also returns traction at targets
%
% Inputs:
%  t = target struct with t.x = M-by-1 list of targets in complex plane
%      and t.nx = M-by-1 list of normals at targets in C-plane, if traction is needed
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     for the 'e' case, s.a one interior point far from bdry.
%  mu = viscosity in Stokes equations (real positive number).
%  dens = single-layer density values (2N-by-1) at nodes, with real values
%     (1-cpts followed by 2-cpts).
%     If dens is empty, output u is the full 2M-by-2N evaluation matrix.
%  side = 'i','e' to indicate targets are all interior or exterior to curve.
%
% Outputs:
%  u = velocity values at targets (2M-by-1): all 1- then all 2-cmpts.
%      Or, if 2M-by-2N velocity evaluation matrix (if dens=[])
%  p = pressure values at targets (M-by-1), or M-by-2N evaluation matrix.
%
% Called without arguments, a self-test (far eval & mat vs StoSLP) is done.
%
% Also see: STOSLP, SETUPQUAD, STOINTDIRBVP

% Bowei Wu, Sept 2014; Barnett 10/8/14 tweaks, repackage 6/13/16, 6/27/16
% viscosity scaling & debug 6/28/16.
% todo: * speed up matrix filling exploiting incoming 0s & dgemm on Lap mats

if nargin==0, test_StoSLP_closeglobal; return; end

N=size(s.x,1); M=size(t.x,1);       % # srcs, # targs
mat = isempty(sigma);
if mat, sigma=eye(2*N); end         % case of dense matrix fill, slow
sigma = sigma(1:N,:)+1i*sigma(N+1:end,:); % work in complex notation
Nc = size(sigma,2);                 % # density vecs (cols), either 1 or 2N

% find I_1
if ~mat                  % eval from single density col vec
  [I1x1, I3x1, I3x2, s1xx,s1xy,s1yy] = LapSLP_closeglobal(t, s, real(sigma), side);
  [I1x2, I4x1, I4x2, s2xx,s2xy,s2yy] = LapSLP_closeglobal(t, s, imag(sigma), side);

else                     % *** specific to the matrix fill case, not arb Nc
  % maybe switch based on nargout here...
  [I1x1, I3x1, I3x2, sxx,sxy,syy] = LapSLP_closeglobal(t, s, eye(N), side);
  I1x2=[zeros(M,N),I1x1];
  I4x1=[zeros(M,N),I3x1];
  I4x2=[zeros(M,N),I3x2];
  I1x1=[I1x1,zeros(M,N)];
  I3x1=[I3x1,zeros(M,N)];
  I3x2=[I3x2,zeros(M,N)];
  s2xx=[zeros(M,N),sxx];   % ahb added...
  s2xy=[zeros(M,N),sxy];
  s2yy=[zeros(M,N),syy];
  s1xx=[sxx,zeros(M,N)];
  s1xy=[sxy,zeros(M,N)];
  s1yy=[syy,zeros(M,N)];
end
I1 = (I1x1+1i*I1x2)/2;

% find I_2
tau = real(bsxfun(@times, s.x, conj(sigma)));   % careful, does y dot sigma
[~, I2x1, I2x2,stxx,stxy,styy] = LapSLP_closeglobal(t, s, tau, side);
I2 = (I2x1+1i*I2x2)/2;

% find I_3
I3 = bsxfun(@times, real(t.x)/2, I3x1+1i*I3x2);

% find I_4
I4 = bsxfun(@times, imag(t.x)/2, I4x1+1i*I4x2);

% Stokes SLP (with viscosity prefactor)
u = (1/mu)*(I1+I2-I3-I4);

u=[real(u);imag(u)];    % back to real notation, always stack [u1;u2]

if nargout>1 % -------- want pressure, do its extension by rotating n_y to sigma
  % & since this rotation makes more osc funcs, must resample to fine grid
  % as in the DLP u. (This pressure extension not in [lsc2d].)
  beta = 1.5;  % >=1: how many times more dense to make fine nodes. Seems enough
  Nf = ceil(beta*numel(s.x)/2)*2;           % nearest even # fine nodes
  sf.x = perispecinterp(s.x,Nf); sf = setupquad(sf);   % build fine nodes
  %sf = setupquad(s,Nf); % uncomment to elim err due to geom interp if have s.Z
  sigf = zeros(Nf,Nc);
  for k=1:Nc
    sigf(:,k) = perispecinterp(sigma(:,k),Nf);   % fine Stokes density
  end
  tauf = bsxfun(@times, sigf, 1./sf.nx);         % 2 complex cmpts
  p = LapDLP_closeglobal(t, sf, tauf, side);     % slow, resampled cols of eye
  % (todo: replace by BLAS3 mat-mat prod, faster)
  p = real(p);
end
%p = nan*u(1:M,:);

%%%%%%--------------
if nargout>2 % traction, down to 10-11 digits
  x1=real(t.x);
  x2=imag(t.x);
  nx1=real(t.nx);
  nx2=imag(t.nx);

  s1x=I3x1;
  s2y=I4x2;

  T1=(s1xx.*nx1+s1xy.*nx2).*x1+(s2xx.*nx1+s2xy.*nx2).*x2...
    -(stxx.*nx1+stxy.*nx2)-(s1x+s2y).*nx1;

  T2=(s1xy.*nx1+s1yy.*nx2).*x1+(s2xy.*nx1+s2yy.*nx2).*x2...
    -(stxy.*nx1+styy.*nx2)-(s1x+s2y).*nx2;

  T=[T1;T2];
  T=-T;
end
%%%%%%--------------


%%%%%%%%%%%%%%%%%%%%
function test_StoSLP_closeglobal          % adapted from Lap tests
fprintf('check Stokes SLP close-eval quadr match native rule in far field...\n')
verb = 0;       % to visualize or not
N = 400;
s = wobblycurve(1,0.3,5,N); s.a = mean(s.x)+0.4+0.2i;   % can't be near bdry
if verb, figure; showsegment(s); plot(s.a,'+'); end
mu = 0.7;       % viscosity (real, pos)

tau = [0.7+sin(3*s.t); -0.4+cos(2*s.t)];  % pick smooth density w/ nonzero mean
nt = 100;
t.nx = exp(2i*pi*rand(nt,1));  % target normals
%profile clear; profile on;
for side = 'ie'
  if side=='e', t.x = 1.5+1i+rand(nt,1)+1i*rand(nt,1);         % distant targs
  else, t.x = 0.6*(rand(nt,1)+1i*rand(nt,1)-(0.5+0.5i)); end % targs far inside
  if verb, plot(t.x,'.'); end
  fprintf('\nside = %s:\n',side)
  [u p T] = StoSLP(t,s,mu,tau);    % eval given density cases...
  tic, [uc pc Tc] = StoSLP_closeglobal(t,s,mu,tau,side);
  %[T Tc abs(T-Tc)]   % testing
  fprintf('Sto SLP density eval (%.3g sec), max abs err in u cmpts, p, T cmpts:\n',toc)
  disp([max(abs(u-uc)), max(abs(p-pc)) , max(abs(T-Tc))])
  tic, [Ac Pc Tc] = StoSLP_closeglobal(t,s,mu,[],side); % fill 20x slower than apply
  fprintf('matrix fill (%.3g sec) & apply, max abs err in u cmpts, p, T cmpts:\n',toc)
  disp([max(abs(u-Ac*tau)), max(abs(p-Pc*tau)), max(abs(T-Tc*tau))])
  [A P T] = StoSLP(t,s,mu);   % native compare matrix els...
  fprintf('matrix fill, max abs matrix element diffs for u, p, T (more stringent, not needed):\n')
  disp([max(abs(A(:)-Ac(:))), max(abs(P(:)-Pc(:))), max(abs(T(:)-Tc(:)))])
end
%profile off; profile viewer
