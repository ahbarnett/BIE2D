function u = StoSLP_closeglobal(t, s, mu, sigma, side)
% STOSLP_CLOSEGLOBAL - close-eval velocity Stokes SLP w/ global quadr curve
%
% u = StoSLP_closeglobal(t,s,mu,dens,side) returns velocities at targets t.x
%  due to double-layer potential with real-valued density dens sampled on the
%  nodes s.x of a smooth global quadrature rule on the curve s, either inside
%  or outside the curve.
%  The SLP is broken down into 3 Laplace SLP potential calls,
%  each of which are evaluated with the globally-compensated scheme.
%  See [lsc2d] for details.
%
% Inputs:
%  t = target struct with t.x = M-by-1 list of targets in complex plane
%  s = curve struct containing N-by-1 vector s.x of source nodes (as complex
%     numbers), and all other fields in s which are generated by quadr(), and
%     s.a one interior point far from bdry (mean(s.x) used if not provided).
%  mu = viscosity in Stokes equations (real positive number).
%  dens = double-layer density values (2N-by-1) at nodes, with real values
%     (1-cpts followed by 2-cpts).
%     If dens is empty, output u is the full 2M-by-2N evaluation matrix.
%  side = 'i','e' to indicate targets are all interior or exterior to curve.
%
% Outputs:
%  u = velocity values at targets (2M-by-1): all 1- then all 2-cmpts.
%      Or, if 2M-by-2N velocity evaluation matrix (if dens=[])
%
% Also see: SETUPQUAD, STOINTDIRBVP, testStokesSDevalclose.m

% Bowei Wu, Sept 2014; Barnett 10/8/14 tweaks, repackage 6/13/16, 6/27/16
% todo: * speed up matrix filling exploiting incoming 0s.

N=size(s.x,1); M=size(t.x,1);       % # srcs, # targs

mat = isempty(sigma);
if mat, sigma=eye(2*N); end         % case of dense matrix
sigma = sigma(1:N,:)+1i*sigma(N+1:end,:);  % put into complex notation

Nc = size(sigma,2);                 % # density vecs (cols), either 1 or 2N

% find I_1
if ~mat                  % eval from single density col vec
    tau = real(sigma);
    [I1x1, I3x1, I3x2] = LapSLP_closeglobal(t, s, tau, side);
    tau = imag(sigma);
    [I1x2, I4x1, I4x2] = LapSLP_closeglobal(t, s, tau, side);
else                      % matrix fill
    [I1x1, I3x1, I3x2] = LapSLP_closeglobal(t, s, eye(N), side);
    I1x2=[zeros(M,N),I1x1];
    I4x1=[zeros(M,N),I3x1];
    I4x2=[zeros(M,N),I3x2];
    I1x1=[I1x1,zeros(M,N)];
    I3x1=[I3x1,zeros(M,N)];
    I3x2=[I3x2,zeros(M,N)];
end
I1 = (I1x1+1i*I1x2)/2;

% find I_2
tau = real((s.x*ones(1,Nc)).*conj(sigma));
[~, I2x1, I2x2] = LapSLP_closeglobal(t, s, tau, side);
I2 = (I2x1+1i*I2x2)/2;

% find I_3
I3 = (real(x)*ones(1,Nc)).*(I3x1+1i*I3x2)/2;

% find I_4
I4 = (imag(x)*ones(1,n)).*(I4x1+1i*I4x2)/2;

% Stokes SLP
u = I1+I2-I3-I4;

u=[real(u);imag(u)];    % always stack [u1;u2]
